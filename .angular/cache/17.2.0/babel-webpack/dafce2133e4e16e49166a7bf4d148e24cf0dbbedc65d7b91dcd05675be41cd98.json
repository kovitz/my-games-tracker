{"ast":null,"code":"import { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./_services/user.service\";\nimport * as i2 from \"./_services/category.service\";\nexport var SessionVariables = /*#__PURE__*/function (SessionVariables) {\n  SessionVariables[\"ActiveUser\"] = \"ActiveUser\";\n  SessionVariables[\"ActiveCategory\"] = \"ActiveCategory\";\n  return SessionVariables;\n}(SessionVariables || {});\n/********************** This is ultimately where all the data magic happens ************************/\n//I tried using inheritance, by creating a base class to give the User services a connection to the Session store,\n//but the engineering got really messy, so I just made one single handler that does all the web requests.\n//I couldn't feel at peace giving the implementers control over the Session store, in fear the logic would be duplicated,\n//or worse, the implementers could behave with it differently. I wanted a base class that takes care of those boilerplate tasks.\n//Any dependency injection is reflected in UserSessionHandler's constructor. EVERYTHING goes through this UserSessionHandler.\n//That could be bad, but who knows!\n//I also realize there's no point returning Observable<any> to invokers.\n//All those invokers naturally subscribe to onSessionLoaded in their constructors\n//TODO: needs a refresh/session token?\n//TODO: might need a global logger that broadcasts error messages\nexport let UserSessionHandler = /*#__PURE__*/(() => {\n  class UserSessionHandler {\n    constructor(userDataService, categoryDataService) {\n      this.userDataService = userDataService;\n      this.categoryDataService = categoryDataService;\n      //UserProfile should be the only one listening\n      this.sessionLoadedEvent = new Subject();\n      this.onSessionLoaded = this.sessionLoadedEvent.asObservable();\n      //these are essentially short-hand queries that get annoying to read\n      this.getCategoryItem = categoryItemId => this.sessionCategory.items.find(x => x.itemId == categoryItemId);\n      this.getRule = ruleCode => this.activeList.rules.find(r => r.code == ruleCode);\n      this.getCard = categoryItemId => this.activeList.rankCards.find(c => c.categoryItemId == categoryItemId);\n      this.getCardRank = (categoryItemId, ruleCode) => this.getCard(categoryItemId).ranks.find(r => r.code == ruleCode);\n      this.refreshCurrentSessionUser = () => this.initializeSessionUser(this.sessionUser.userId);\n    }\n    triggerSessionLoaded(event) {\n      this.sessionLoadedEvent.next(event);\n    }\n    /************ Always invoke this in OnInit of the main user container! *************/\n    initializeSessionUser(id, changedActiveListId) {\n      //make a clean data pull, don't want any concurrency issues\n      sessionStorage.clear();\n      //get the user\n      this.userDataService.getUser(id).subscribe(userResult => {\n        if (changedActiveListId) {\n          //if user wants to switch lists, send update to database then login again (HAS NOT BEEN TESTED)\n          userResult.config.lastActiveListId = changedActiveListId;\n          this.userDataService.updateUser(userResult).subscribe(() => this.initializeSessionUser(id));\n        } else {\n          //this is the general case\n          sessionStorage.setItem(SessionVariables.ActiveUser, JSON.stringify(userResult));\n          //get the category associated with user.config.lastActiveListId\n          this.categoryDataService.getCategory(this.activeList.categoryId).subscribe(categoryResult => {\n            console.log('getCategory after mockLoginNewUser');\n            console.log(categoryResult);\n            sessionStorage.setItem(SessionVariables.ActiveCategory, JSON.stringify(categoryResult));\n            this.triggerSessionLoaded(userResult);\n          });\n        }\n      });\n    }\n    //wrappers for sessionStorage\n    get sessionUser() {\n      return JSON.parse(sessionStorage.getItem(SessionVariables.ActiveUser));\n    }\n    get sessionCategory() {\n      return JSON.parse(sessionStorage.getItem(SessionVariables.ActiveCategory));\n    }\n    get activeList() {\n      return this.sessionUser.rankCardLists.find(l => l.listId == this.sessionUser.config.lastActiveListId);\n    }\n    updateThenGetUser(card) {\n      var user = this.sessionUser;\n      user.rankCardLists.find(l => l.listId == this.activeList.listId).rankCards.push(card);\n      return user;\n    }\n    //caller is responsible for tracking new category item details\n    //if there is no new categoryItem, we assume there's already a match\n    addRankCardForSessionUser(card, categoryItem) {\n      //send the RankCard to the database, then refresh the user session data\n      const newUserData = this.updateThenGetUser(card);\n      console.log('PREupdateResult:');\n      console.log(card);\n      if (categoryItem) this.userDataService.addLinkedRankCard(card, categoryItem, this.sessionUser, this.sessionCategory).subscribe(updateResult => {\n        console.log('updateResult:');\n        console.log(updateResult);\n        this.refreshCurrentSessionUser();\n      });else this.userDataService.updateUser(newUserData).subscribe(updateResult => {\n        console.log('updateResult:');\n        console.log(updateResult);\n        this.refreshCurrentSessionUser();\n      });\n    }\n    static #_ = this.ɵfac = function UserSessionHandler_Factory(t) {\n      return new (t || UserSessionHandler)(i0.ɵɵinject(i1.IUserService), i0.ɵɵinject(i2.ICategoryService));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: UserSessionHandler,\n      factory: UserSessionHandler.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return UserSessionHandler;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}